<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>GOD: Chess Grid Generator</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #1a1a1a;
            color: #eee;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Панель управления */
        #controls {
            width: 320px;
            background: #252525;
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            z-index: 10;
        }

        h2 { margin-top: 0; color: #00ff88; } /* Зеленый акцент для новой версии */
        
        .control-group {
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #aaa;
        }

        input[type="range"] { width: 100%; }
        input[type="number"] { width: 60px; background: #444; color: white; border: none; padding: 4px; }
        input[type="color"] { width: 100%; height: 30px; border: none; cursor: pointer; }
        
        button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 10px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: 0.2s;
        }
        button:hover { background: #55ffaa; }

        /* Область просмотра */
        #viewport {
            flex-grow: 1;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            position: relative;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            max-width: none; /* Убираем ограничение, чтобы не мылило при зуме браузера */
        }

        .val-display { float: right; color: #fff; font-weight: bold; }
    </style>
</head>
<body>

<div id="controls">
    <h2>Генератор сетки </h2>
    
    <div class="control-group">
        <label>1. Загрузить карту</label>
        <input type="file" id="imageLoader" accept="image/*">
    </div>

    <div class="control-group">
        <label>Размер Сектора (px) <span id="val-size" class="val-display">150</span></label>
        <input type="range" id="sectorSize" min="30" max="600" value="150">
        <div style="font-size: 0.8em; color: #777; margin-top:5px;">
            Размер клетки: <span id="cellSizeDisplay">50</span>px
        </div>
    </div>

    <div class="control-group">
        <label>Смещение сетки X / Y</label>
        <input type="range" id="offsetX" min="0" max="300" value="0">
        <input type="range" id="offsetY" min="0" max="300" value="0">
    </div>

    <div class="control-group">
        <label>Линии Секторов (Макро)</label>
        <input type="color" id="colorMacro" value="#00ff88">
        <label>Прозрачность</label>
        <input type="range" id="alphaMacro" min="0" max="1" step="0.1" value="0.8">
        <label>Толщина</label>
        <input type="number" id="widthMacro" value="3">
    </div>

    <div class="control-group">
        <label>Линии Клеток (Микро)</label>
        <input type="color" id="colorMicro" value="#ffffff">
        <label>Прозрачность</label>
        <input type="range" id="alphaMicro" min="0" max="1" step="0.1" value="0.2">
    </div>

    <div class="control-group">
        <label>Координаты (A1, B2...)</label>
        <input type="color" id="colorText" value="#ffffff">
        <label>Размер шрифта</label>
        <input type="range" id="fontSize" min="10" max="100" value="28">
        <label><input type="checkbox" id="showCoords" checked> Координаты Секторов</label>
        <label><input type="checkbox" id="showNumpad"> Numpad внутри (1-9)</label>
    </div>

    <button id="downloadBtn">Экспортировать карту</button>
</div>

<div id="viewport">
    <canvas id="mapCanvas"></canvas>
    <div id="placeholder" style="color: #555; position: absolute;">Загрузите изображение</div>
</div>

<script>
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    const loader = document.getElementById('imageLoader');
    
    let img = new Image();
    let loaded = false;

    const controls = {
        sectorSize: document.getElementById('sectorSize'),
        offsetX: document.getElementById('offsetX'),
        offsetY: document.getElementById('offsetY'),
        colorMacro: document.getElementById('colorMacro'),
        alphaMacro: document.getElementById('alphaMacro'),
        widthMacro: document.getElementById('widthMacro'),
        colorMicro: document.getElementById('colorMicro'),
        alphaMicro: document.getElementById('alphaMicro'),
        colorText: document.getElementById('colorText'),
        fontSize: document.getElementById('fontSize'),
        showCoords: document.getElementById('showCoords'),
        showNumpad: document.getElementById('showNumpad')
    };

    loader.addEventListener('change', handleImage, false);
    document.getElementById('downloadBtn').addEventListener('click', download);
    
    Object.values(controls).forEach(el => {
        el.addEventListener('input', draw);
    });

    function handleImage(e) {
        const reader = new FileReader();
        reader.onload = function(event) {
            img.onload = function() {
                loaded = true;
                document.getElementById('placeholder').style.display = 'none';
                controls.offsetX.max = controls.sectorSize.value;
                controls.offsetY.max = controls.sectorSize.value;
                draw();
            }
            img.src = event.target.result;
        }
        reader.readAsDataURL(e.target.files[0]);
    }

    // Функция перевода числа в буквы (0->A, 1->B, 26->AA)
    function toLetters(num) {
        let letters = '';
        while (num >= 0) {
            letters = String.fromCharCode(num % 26 + 65) + letters;
            num = Math.floor(num / 26) - 1;
        }
        return letters;
    }

    function draw() {
        if (!loaded) return;

        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        const secSize = parseInt(controls.sectorSize.value);
        const cellSize = secSize / 3;
        const offX = parseInt(controls.offsetX.value);
        const offY = parseInt(controls.offsetY.value);

        document.getElementById('val-size').textContent = secSize;
        document.getElementById('cellSizeDisplay').textContent = Math.round(cellSize);
        controls.offsetX.max = secSize;
        controls.offsetY.max = secSize;

        const cols = Math.ceil(canvas.width / cellSize);
        const rows = Math.ceil(canvas.height / cellSize);

        // Рисуем линии
        // Вертикаль
        for (let i = 0; i <= cols; i++) {
            const x = offX + (i * cellSize);
            if (x > canvas.width) break;
            ctx.beginPath();
            if (i % 3 === 0) {
                ctx.strokeStyle = hexToRgba(controls.colorMacro.value, controls.alphaMacro.value);
                ctx.lineWidth = parseInt(controls.widthMacro.value);
            } else {
                ctx.strokeStyle = hexToRgba(controls.colorMicro.value, controls.alphaMicro.value);
                ctx.lineWidth = 1;
            }
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        // Горизонталь
        for (let i = 0; i <= rows; i++) {
            const y = offY + (i * cellSize);
            if (y > canvas.height) break;
            ctx.beginPath();
            if (i % 3 === 0) {
                ctx.strokeStyle = hexToRgba(controls.colorMacro.value, controls.alphaMacro.value);
                ctx.lineWidth = parseInt(controls.widthMacro.value);
            } else {
                ctx.strokeStyle = hexToRgba(controls.colorMicro.value, controls.alphaMicro.value);
                ctx.lineWidth = 1;
            }
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        // Текст координат
        const fontSize = parseInt(controls.fontSize.value);
        ctx.fillStyle = controls.colorText.value;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        // Шрифт Orbitron для красоты, если загружен в системе, иначе sans-serif
        ctx.font = `bold ${fontSize}px "Orbitron", sans-serif`;

        const numSectorsX = Math.ceil((canvas.width - offX) / secSize);
        const numSectorsY = Math.ceil((canvas.height - offY) / secSize);

        for (let sy = 0; sy < numSectorsY; sy++) {
            for (let sx = 0; sx < numSectorsX; sx++) {
                const sectorCenterX = offX + (sx * secSize) + (secSize / 2);
                const sectorCenterY = offY + (sy * secSize) + (secSize / 2);

                // Координаты шахматного типа
                if (controls.showCoords.checked) {
                    const labelX = toLetters(sx); // A, B, C...
                    const labelY = sy + 1;        // 1, 2, 3...
                    
                    // Рисуем тень (обводку) текста для читаемости
                    ctx.strokeStyle = 'rgba(0,0,0,0.8)';
                    ctx.lineWidth = 4;
                    ctx.strokeText(`${labelX}${labelY}`, sectorCenterX, sectorCenterY);
                    
                    ctx.fillText(`${labelX}${labelY}`, sectorCenterX, sectorCenterY);
                }

                if (controls.showNumpad.checked) {
                    ctx.font = `bold ${fontSize * 0.4}px sans-serif`;
                    
                    for(let dy=0; dy<3; dy++) {
                        for(let dx=0; dx<3; dx++) {
                            const num = ((2-dy)*3) + (dx+1);
                            const cx = offX + (sx * secSize) + (dx * cellSize) + (cellSize/2);
                            const cy = offY + (sy * secSize) + (dy * cellSize) + (cellSize/2);
                            
                            ctx.fillStyle = `rgba(255,255,255, 0.6)`;
                            ctx.fillText(num, cx, cy);
                        }
                    }
                    // Возвращаем настройки шрифта для следующей итерации координат
                    ctx.fillStyle = controls.colorText.value;
                    ctx.font = `bold ${fontSize}px "Orbitron", sans-serif`;
                }
            }
        }
    }

    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function download() {
        if(!loaded) return;
        const link = document.createElement('a');
        link.download = 'map-chess-grid.png';
        link.href = canvas.toDataURL();
        link.click();
    }
</script>

</body>
</html>